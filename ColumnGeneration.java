/**
 * 
 */
package com.ibm.optim.oaas.sample.optimization;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;

import com.ibm.optim.sample.oplinterface.OPLCollector;
import com.ibm.optim.sample.oplinterface.OPLGlobal;
import com.ibm.optim.sample.oplinterface.OPLTuple;

/**
 * This class solves a mathematical program using the column generation 
 * algorithm. The optimization model must be factored into a Master problem 
 * and a single Subproblem. The actual problem to be solved is  
 * completely transparent to this class and is specified by the Master 
 * and Subproblem models and their respective input and output collectors. The 
 * actual solves are delegated to the class <code>Optimizer</code>.
 * 
 * In order to use the algorithm, you must first define two optimization problems, a master problem and a subproblem.
 * How to do so is beyond the scope of this documentation, but there are many standard textbooks on optimization that can show you how.
 * Each optimization model is embodied in an OPL .mod file (or two, if you want to separate the data model from the optimization model) 
 * and a corresponding Optimizer object.
 * Each of the master and subproblem inputs and outputs has its own application data model, which you must specify using the OPLCollector.ADMBuilder. Based on them, 
 * you must create OPLCollector instances representing the input data; the OPLCollector class provides a number of ways to read the application data into its Spark tables. 
 * The output results collectors are generated by the Optimizer.solve method (which is called repeatedly by the decomposition algorithm).
 * You must also define the linkages between the master problem and the subproblem. Linkages specify a set of tables
 * in the application data model that are exchanged between the master and subproblems. Two types of linkages are permitted:
 * In linking the subproblem to the master, data from the subproblem are added to the corresponding tables in the master problem. 
 * In linking the master to the subproblem, data from the master problem replace the corresponding tables in the subproblem. The links are specified by Linkage objects.
 * You also have to specify the convergence criterion, since the decomposition algorithm is a iterative process.
 * You can specify the convergence criterion by creating a ConvergenceTest object, overriding the abstract method 
 * hasConverged with your own test. The ConvergenceTest object also holds the initial master and subproblem bounds.
 * To tell the algorithm where to find the bounds, use Linkage.specifyBound method to identify the table in the respective master or subproblem
 * result collector and the field where the bound is to be found. It is also important to pass the iteration count, which is used for, among other things,
 * identifying the data items generated during each iteration. Use the Linkage.specifyIterationCounter method 
 * to identify the input data collector table and field where the iteration count should be stored.
 * 
 * 
 * @author bloomj
 *
 */
public class ColumnGeneration {
	
	private String label;
	private ConvergenceTest convergenceTest;
	private int iterations;

	// Optimization models
	private Optimizer master; 
	private Optimizer subproblem;
	

	// Optimization Results	
	private OPLCollector masterResult;
	private OPLCollector subproblemResult;
	
	private Linkage fromSubproblem;
	private Linkage fromMaster;

	/**
	 * Constructs a ColumnGeneration instance.
	 * 
	 * @param label the name of this instance
	 * @param convergenceTest provide the convergenceTest test for the decomposition (null if not present)
	 * @param fromSubproblem the subproblem result tables linking to the master (null if not present)
	 * @param master the master problem (null if not present)
	 * @param fromMaster the master problem tables linking to the subproblem (null if not present)
	 * @param subproblem (null if not present)
	 */
	public ColumnGeneration(String label, ConvergenceTest convergenceTest, Linkage fromSubproblem, Optimizer master, Linkage fromMaster, Optimizer subproblem) {
		this.label= label;
		this.convergenceTest= convergenceTest;
		this.fromSubproblem= fromSubproblem;
		this.master= master; 
		this.fromMaster= fromMaster;
		this.subproblem= subproblem;
		this.masterResult= null;
		this.subproblemResult= null;
		this.iterations= 0;
	}
	
	public ColumnGeneration(String label) {
		this(label, null, null, null, null, null);
	}
	
	/**
	 * Specifies the test to be used for convergence of the decomposition iterations.
	 * 
	 * @param convergenceTest
	 * @return this ColumnGeneration instance
	 */
	public ColumnGeneration setConvergenceTest(ConvergenceTest convergenceTest) {
		if(this.convergenceTest != null)
			throw new IllegalArgumentException("convergenceTest has already been set");
		this.convergenceTest = convergenceTest;
		return this;
	}

	/**
	 * Specifies the master problem.
	 * 
	 * @param master
	 * @param fromMaster
	 * @return this ColumnGeneration instance
	 */
	public ColumnGeneration setMaster(Optimizer master, Linkage fromMaster) {
		if(this.master != null)
			throw new IllegalArgumentException("master has already been set");
		if(this.fromMaster != null)
			throw new IllegalArgumentException("fromMaster has already been set");
		this.master = master;
		this.fromMaster = fromMaster;
		return this;
	}

	/**
	 * Specifies the subproblem.
	 * 
	 * @param subproblem
	 * @param fromSubproblem
	 * @return this ColumnGeneration instance
	 */
	public ColumnGeneration setSubproblem(Optimizer subproblem, Linkage fromSubproblem) {
		if(this.subproblem != null)
			throw new IllegalArgumentException("subproblem has already been set");
		if(this.fromSubproblem != null)
			throw new IllegalArgumentException("fromSubproblem has already been set");
		this.subproblem = subproblem;
		this.fromSubproblem = fromSubproblem;
		return this;
	}

	public String getLabel() {
		return this.label;
	}
	
	public OPLCollector getMasterResult() {
		return masterResult;
	}

	public OPLCollector getSubproblemResult() {
		return subproblemResult;
	}
	
	/**
	 * Executes the column generation algorithm.
	 * This method is designed to permit restarting the iterations with additional iterations 
	 * and a refined convergence tolerance. The collectors masterData and Subproblem data are updated during the iteration, 
	 * so that they can be used in a restart. Simply call the optimize method again with a new value of maxIterations, using 
	 * the Terminator.setTolerance method to change the convergence tolerance if desired.
	 * 
	 * @param masterData inputs to the master problem
	 * @param subproblemData inputs to the subproblem
	 * @param maxIterations maximum number of iterations permitted
	 * @return the master problem solution on the final iteration 
	 */
	public OPLCollector optimize(OPLCollector masterData, OPLCollector subproblemData, int maxIterations) {
		
		Double masterBound= convergenceTest.getInitialMasterBound();
		Double subproblemBound= convergenceTest.getInitialSubproblemBound();

		while(this.iterations < maxIterations && !convergenceTest.hasConverged(masterBound, subproblemBound)) {

			// Set up and solve Master Problem
			if(this.iterations > 0) {
				for(String tableName: fromSubproblem.getTablesToUpdate())
					masterData.addData(tableName, subproblemResult.getTable(tableName), subproblemResult.getSize(tableName));
			}
			fromSubproblem.setIterationCount(masterData, this.iterations);
			
			OPLGlobal.out.println("In ColumnGeneration.optimize: Iteration= " + this.iterations);
			OPLGlobal.out.println();
			OPLGlobal.out.println("Solve Master problem");
			OPLGlobal.out.println();
			masterData.show(OPLGlobal.out);
			
			this.iterations++;
			masterResult= master.solve(masterData, Integer.toString(this.iterations));
			if(fromMaster.getBound(masterResult)!=null ) //if null, masterBound is unchanged
				masterBound= fromMaster.getBound(masterResult);
			OPLGlobal.out.println("Master Problem bound: " + masterBound);
	
			// Set up and solve Subproblem
			for(String tableName: fromMaster.getTablesToReplace())
				subproblemData.replaceTable(tableName, masterResult.getTable(tableName), masterResult.getSize(tableName));
			fromMaster.setIterationCount(subproblemData, this.iterations);
			
			OPLGlobal.out.println("Solve Subproblem");
			OPLGlobal.out.println();
			subproblemData.show(OPLGlobal.out);
			
			subproblemResult= subproblem.solve(subproblemData, Integer.toString(this.iterations));
			if(fromSubproblem.getBound(subproblemResult)!=null ) //if null, subproblemResult is unchanged
				subproblemBound= fromSubproblem.getBound(subproblemResult);
			OPLGlobal.out.println("Subproblem bound: " + subproblemBound);
			OPLGlobal.out.println();
		
		}/*while*/
		
		master.shutdown();
		subproblem.shutdown();	
		
		return masterResult;
		
	}/*optimize method*/
	
	/**
	 * A static factory that creates a linkage.
	 * 
	 * @return a new Linkage instance
	 */
	static ColumnGeneration.Linkage makeLink() {
		return new ColumnGeneration.Linkage();
	}
	
	/**
	 * Identifies the Linkages between the master and subproblems.
	 * The linkage is a list of table names in the relevant results (output) collector.
	 * The optimize method iterates through the linkage list, transferring the data to the relevant data (input) collector.
	 * Linking tables must be identically named and have identical schemas in the master and subproblems.
	 * 
	 * This class also enables accessing the reduced cost from the subproblem results collector (not used for the master results collector).
	 * 
	 * @author bloomj
	 *
	 */
	public static class Linkage {
		
		private List<String> addData;
		private List<String> replaceData;
		private Map<String, String> bound;
		private Map<String, String> iterationCounter;
		
		/**
		 * Specifies linking items for transfer of data from the master to the subproblem or vice versa.
		 * You will need to write the optimization models for the master and subproblems to use and generate these items.
		 * 
		 * @param tables the names of the tables to be transferred
		 */
		public Linkage() {
			super();
			addData= new ArrayList<String>();
			replaceData= new ArrayList<String>();
			bound= null;
			iterationCounter= null;
		}
		
		/**
		 * Specify tables linked by adding data.
		 * Used only in the transfer to master linkage; empty in the transfer to subproblem linkage.
		 * 
		 * @param tables
		 * @return this Linkage
		 */
		public Linkage addDataTo(String... tables) {
			if(!addData.isEmpty())
				throw new IllegalArgumentException("tables to add data have already been set");
			addData.addAll(Arrays.asList(tables));
			return this;
		}

		/**
		 * Specify tables linked by replacing data.
		 * Used only in the transfer to subproblem linkage; empty in the transfer to master linkage.
		 * 
		 * @param tables
		 * @return this Linkage
		 */
		public Linkage replaceDataIn(String... tables) {
			if(!replaceData.isEmpty())
				throw new IllegalArgumentException("tables to replace data have already been set");
			replaceData.addAll(Arrays.asList(tables));
			return this;
		}
		
		/**
		 * Gets the list of tables linked by adding data.
		 * 
		 * @return an unmodifiable list
		 */
		List<String> getTablesToUpdate() {
			return Collections.unmodifiableList(addData);
		}

		/**
		 * Gets the list of tables linked by replacing data.
		 * 
		 * @return an unmodifiable list
		 */
		List<String> getTablesToReplace() {
			return Collections.unmodifiableList(replaceData);
		}

		/**
		 * Indicates where to find the bound (typically a decision expression value) in an optimization problem.
		 * It is assumed that the table holding the bound has only a single row (otherwise only the first row is used).
		 * Specifying a bound is optional; if one is not specified (i.e. it is null), the initial bound will be used constantly.
		 * If the table name is "constant" (ignoring case), the bound is set to null and the initial bound will be used constantly; 
		 * in this case, the field name is ignored.
		 * 
		 * @param problemName the name of the problem generating the bound (a convenience field that is not used elsewhere)
		 * @param tableName in the result collector containing the bound 
		 * (this is typically the table that returns the objective function value)
		 * @param fieldName of the field in the table containing the bound value
		 * @return this linkage
		 */
		public Linkage specifyBound(String problemName, String tableName, String fieldName) {
			if(this.bound!= null)
				throw new IllegalArgumentException("bound has already been specified");
			if(!tableName.equalsIgnoreCase("constant")) {
				this.bound= new HashMap<String, String>();
				this.bound.put("tableName", tableName);
				this.bound.put("fieldName", fieldName);
			}
			else 
				this.bound= null;
			return this;
		}
		
		/**
		 * Accesses the bound from a result collector.
		 * If the bound has not been specified, returns null.
		 * 
		 * @return the bound if it has been specified, null if not.
		 */
		public Double getBound(OPLCollector result) {
			if(this.bound==null)
				return null;
			String tableName= this.bound.get("tableName");
			String fieldName= this.bound.get("fieldName");
			Dataset<Row> table= result.getTable(tableName);
			Row row= table.first();
			return row.getDouble(row.fieldIndex(fieldName));
		}
		
		/**
		 * Indicates where to find the iteration count.
		 * It is assumed that the table holding the iteration count has only a single row.
		 * 
		 * @param tableName in the data collector containing the iteration count 
		 * (this is typically a parameters table)
		 * @param fieldNname of the field in the table containing the iteration count
		 * @return this linkage
		 */
		public Linkage specifyIterationCounter(String tableName, String fieldName) {
			if(this.iterationCounter!= null)
				throw new IllegalArgumentException("iteration counter has already been set");
			this.iterationCounter= new HashMap<String, String>();
			this.iterationCounter.put("tableName", tableName);
			this.iterationCounter.put("fieldName", fieldName);		
			return this;
		}
		
		/**
		 * Returns the iteration count from the collector
		 * 
		 * @param collector
		 * @return
		 */
		public Integer getIterationCount(OPLCollector collector) {
			String tableName= this.iterationCounter.get("tableName");
			String fieldName= this.iterationCounter.get("fieldName");
			Dataset<Row> table= collector.getTable(tableName);
			Row row= table.first();
			return row.getInt(row.fieldIndex(fieldName));		
		}
		
		/**
		 * Sets the value of the iteration count and replacements its table in the collector.
		 * 
		 * @param collector where the iteration is to be set
		 * @param count the new count value
		 * @return a new table with the same field values except for the iteration count
		 */
		public void setIterationCount(OPLCollector collector, Integer count) {
			String tableName= this.iterationCounter.get("tableName");
			String fieldName= this.iterationCounter.get("fieldName");
			Dataset<Row> table= collector.getTable(tableName);
			Row row= table.first();
			OPLTuple tuple= (new OPLTuple(OPLTuple.defaultName(tableName), collector.getSchema(tableName), row)).replace(fieldName, count);
			collector.replaceTable(tableName, tuple.asSingleton());
		}	
		
	}/*class Linkage*/
	
	/**
	 * Defines a termination criterion for the decomposition.
	 * 
	 * @author bloomj
	 *
	 */
	public static class ConvergenceTest {
		
		protected Double epsilon;
		private Double initialMasterBound;
		private Double initialSubproblemBound;
		
		public ConvergenceTest() {
			super();
			epsilon= null;
			initialMasterBound= null;
			initialSubproblemBound= null;
		}

		/**
		 * Gets the tolerance, epsilon, for concluding the decomposition has converged.
		 * 
		 * @return the tolerance
		 */
		public Double getTolerance() {
			return epsilon;
		}

		
		/**
		 * Sets the tolerance for concluding the decomposition has converged.
		 * 
		 * @param epsilon
		 * @return this ConvergenceTest instance
		 */
		public ConvergenceTest setTolerance(Double epsilon) {
			this.epsilon= epsilon;
			return this;
		}
	
		/**
		 * Sets the initial master problem bound.
		 * 
		 * @param masterBound
		 * @return this Terminator instance
		 * @throws IllegalArgumentException if the initial bound has already been set
		 */
		public ConvergenceTest setInitialMasterBound(Double masterBound) {
			if(initialMasterBound!=null)
				throw new IllegalArgumentException("initial master problem bound has already been set.");
			initialMasterBound= masterBound;
			return this;
		}
		
		public Double getInitialMasterBound() {
			return initialMasterBound;
		}

		/**
		 * Sets the initial subproblem bound.
		 * 
		 * @param subproblemBound
		 * @return this Terminator instance
		 * @throws IllegalArgumentException if the initial bound has already been set
		 */
		public ConvergenceTest setInitialSubproblemBound(Double subproblemBound) {
			if(initialSubproblemBound!=null)
				throw new IllegalArgumentException("initial subproblem bound has already been set.");
			initialSubproblemBound= subproblemBound;
			return this;
		}

		public Double getInitialSubproblemBound() {
			return initialSubproblemBound;
		}
		
		/**
		 * Determines whether the decomposition has converged.
		 * 
		 * @param masterBound
		 * @param subproblemBound
		 * @return true if the convergenceTest criterion is satisfied, false otherwise
		 */
		public boolean hasConverged(Double masterBound, Double subproblemBound) {
			return Math.abs(masterBound-subproblemBound) < getTolerance();
		}
		
	}/*class ConvergenceTest*/


}/*class ColumnGeneration*/
